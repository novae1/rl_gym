% finds the equalibrium point in the game of two players, that arises in
% decentralized noncooperative case.

% the problem is solved by means of LCP
% NOTE: this program uses PATH package, which should be properly installed: 
%       in case of no license PATH will fail to solve the problem larger then 5x5 
%       (see the documentation)

% the problem should be defined in file DEFS

% 
% the solution is available in variables W1(i,a), W2(i,a)
% the occupation measures are available in variables RHO1(i,a), RHO2(i,a) 

% the values of the players cost functions can be computed using COSTS
% the supports plots can be generated by PLOTSUPPS(W1,V1,W2,V2),
%     where V1 and V2 are power bounds



% addpath ./path


function [val1,val2,rho1,rho2]=queue_lcp(inputargs)

queueclear;

queuedefs;

NVars = NStates; % Number of variables (for each mobile)
A = zeros(NStates,NStates);
B = zeros(NStates,NStates);


maxe=-1

% A and B store the cost functions

minc = 0;


for i = 1:NLinkStates                            % pl 1
	for j = 1:NBufferStates						 % pl 1
    	for a = 1:NPowActs						 % pl 1
			for b= 1:NAdmContrActs				 % pl 1
				for c= 1:NSrvContrActs 			 % pl 1
					
					for k = 1:NLinkStates        % pl 2
						for l = 1:NBufferStates	 % pl 2	
							for d = 1:NPowActs	 % pl 2
								for e= 1:NAdmContrActs				
									for f= 1:NSrvContrActs 			
	
										if (( (l-1) > 0 ) & ( (j-1) > 0 ))
											A(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))=c1(i,a,k,d);
										elseif (( (l-1) > 0 ) & ( (j-1) == 0 ))
											A(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))=c1(i,1,k,d);
										elseif (( (l-1) == 0 ) & ( (j-1) > 0 ))
											A(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))=c1(i,a,k,1);
										end

										if (( (l-1) > 0 ) & ( (j-1) > 0 ))
											B(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))=c2(i,a,k,d);
										elseif (( (l-1) > 0 ) & ( (j-1) == 0 ))
											B(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))=c2(i,1,k,d);
										elseif (( (l-1) == 0 ) & ( (j-1) > 0 ))
											B(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))=c2(i,a,k,1);
										end
										
										if  ((B(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))) > 0) 
										
											if ((B(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))) > maxe) 
											
												maxe  = B(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f));
											
											end
											
										end

										if  ((A(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))) > 0) 
										
											if ((A(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f))) > maxe) 
											
												maxe  = A(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f));
											
											end
											
										end
										
									end
								end
							end
						end
					end
				end
            end
        end
    end
end

origcost1 = A;
origcost2 = A;

A = A-maxe*ones(size(A));
B = B-maxe*ones(size(B));



% ---------------------------------------------------------------
% G and g are related to the channel and buffer transitions
% [balance equations (flow in = flow out)]
% ---------------------------------------------------------------

G = zeros(NLinkStates*NBufferStates,NStates);

for y = 1 : NLinkStates
	for z = 1 : NBufferStates
	
		for i = 1:NLinkStates
			for j = 1:NBufferStates
    			for a = 1:NPowActs
					for b= 1:NAdmContrActs
						for c= 1:NSrvContrActs
						
    			    		G(queuestate(y,z),queuepos1(i,j,a,b,c)) = (((i==y) & (j==z)) - P(j,a,b,c,z)*PL(i,y));
							
	    				end
					end
				end
			end
		end
		
		g(queuestate(y,z)) = 0; % ones(NLink,1)/NLink;
		
	end
end

g = g';



% ---------------------------------------------------------------
% constraints
% ---------------------------------------------------------------


temp1 = zeros(1,NVars);

for i = 1:NLinkStates
	for j = 1:NBufferStates
    	for a = 1:NPowActs
			for b= 1:NAdmContrActs
				for c= 1:NSrvContrActs

					if ( j > 1 )
						temp1(queuepos1(i,j,a,b,c)) = a-1;
					else
						temp1(queuepos1(i,j,a,b,c)) = 0;
					end

				end
			end
		end
    end
end

temp2 = zeros(1,NVars);

for i = 1:NLinkStates
	for j = 1:NBufferStates
    	for a = 1:NPowActs
			for b= 1:NAdmContrActs
				for c= 1:NSrvContrActs

					if ( j > 1 )
						temp2(queuepos1(i,j,a,b,c)) = a-1;
					else
						temp2(queuepos1(i,j,a,b,c)) = 0;
					end

				end
			end
		end
    end
end


E = [G;temp1;ones(1,NVars)];
F = [G;temp2;ones(1,NVars)];



e = [g; v1; 1];
f = [g; v2; 1];


O = zeros (NVars,NVars);
oo = zeros (size(E));
o  = zeros (size(E,1),size(E,1));


M = [ O,  -A, E', -E', oo',  oo' ;
     -B',  O, oo',  oo', F', -F';
     -E,   oo, o,  o, o,  o; 
      E,   oo, o,  o, o,  o; 
      oo,  -F, o,  o, o,  o; 
      oo,   F, o,  o, o,  o]; 


qo = zeros(NVars,1);

q = [qo;qo;e;-e;f;-f];



% ------------------------
% solving the lcp
% ------------------------



if (isnan(rho1))

	X1 = pathlcp(M,q);
	
else

    X1 = mypathlcp(inputargs,M,q,rho1,rho2,A,B,e,f,E,F);

end



type logfile.tmp



% ------------------------
% processing the output
% ------------------------


X = X1(1:2*NStates)





e1 = zeros(size(X));
e2 = zeros(size(X));

for i = 1:NLinkStates
	for j = 1:NBufferStates
    	for a = 1:NPowActs
			for b= 1:NAdmContrActs
				for c= 1:NSrvContrActs

        			e1(queuepos1(i,j,a,b,c)) = 1;
        			e2(NStates+queuepos1(i,j,a,b,c)) = 1;
					
				end
			end
		end
    end
end

Xn1 = X/(e1'*X);
Xn2 = X/(e2'*X);


rho1 = zeros(NLinkStates,NBufferStates,NPowActs,NAdmContrActs,NSrvContrActs);
rho2 = zeros(NLinkStates,NBufferStates,NPowActs,NAdmContrActs,NSrvContrActs);

x = zeros(NLinkStates*NBufferStates*NPowActs*NAdmContrActs*NSrvContrActs,1);
y = zeros(NLinkStates*NBufferStates*NPowActs*NAdmContrActs*NSrvContrActs,1);

for i = 1:NLinkStates
	for j = 1:NBufferStates
    	for a = 1:NPowActs
			for b= 1:NAdmContrActs
				for c= 1:NSrvContrActs
        			rho1(i,j,a,b,c) = Xn1(queuepos1(i,j,a,b,c));
        			rho2(i,j,a,b,c) = Xn2(NStates+queuepos1(i,j,a,b,c));
        			x(queuepos1(i,j,a,b,c)) = Xn1(queuepos1(i,j,a,b,c));
        			y(queuepos1(i,j,a,b,c)) = Xn2(NStates+queuepos1(i,j,a,b,c));

				end
			end
		end
    end
end


% ------------------------
% results
% ------------------------

w1 = zeros(NLinkStates,NBufferStates,NPowActs,NAdmContrActs,NSrvContrActs);
w2 = zeros(NLinkStates,NBufferStates,NPowActs,NAdmContrActs,NSrvContrActs);

for i = 1 : NLinkStates
	for j = 1 : NBufferStates
    	dd1 = sum(sum(sum(rho1(i,j,:,:,:))));
    	dd2 = sum(sum(sum(rho2(i,j,:,:,:))));
    	for a = 1 : NPowActs
	    	for b = 1 : NAdmContrActs
		    	for c = 1 : NSrvContrActs
	        		w1(i,j,a,b,c) = rho1(i,j,a,b,c)/dd1;
    		    	w2(i,j,a,b,c) = rho2(i,j,a,b,c)/dd2;
				end
			end
    	end
	end
end



plotsuppsmdp(inputargs,w1);
plotsuppsmdp(inputargs,w2);



cost1 = 0;
cost2 = 0;



for i = 1:NLinkStates                            % pl 1
	for j = 1:NBufferStates						 % pl 1
    	for a = 1:NPowActs						 % pl 1
			for b= 1:NAdmContrActs				 % pl 1
				for c= 1:NSrvContrActs 			 % pl 1
					for k = 1:NLinkStates        % pl 2
						for l = 1:NBufferStates	 % pl 2	
							for d = 1:NPowActs	 % pl 2
								for e= 1:NAdmContrActs				
									for f= 1:NSrvContrActs 			
										cost1 = cost1 +  origcost1(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f)) * rho1(i,j,a,b,c) * rho2(k,l,d,e,f);
										cost2 = cost2 +  origcost2(queuepos1(i,j,a,b,c),queuepos1(k,l,d,e,f)) * rho1(i,j,a,b,c) * rho2(k,l,d,e,f);
										
									end
								end
							end
						end
					end
				end
			end
		end
	end
end


val1 = cost1;
val2 = cost2;


constraint1 = 0;
constraint2 = 0;

for i = 1 : NLinkStates
	for j = 1 : NBufferStates
    	for a = 1:NPowActs
			for b= 1:NAdmContrActs
				for c= 1:NSrvContrActs


				
					if ( j > 1 )
						constraint1 =  constraint1 + rho1(i,j,a,b,c) * (a-1);					
						constraint2 =  constraint2 + rho2(i,j,a,b,c) * (a-1);											
					else
						constraint1 =  constraint1 + rho1(i,j,a,b,c) * 0;										
						constraint2 =  constraint2 + rho2(i,j,a,b,c) * 0;										
					end

					
					
				end
			end
		end
    end
end




constraint1
constraint2


plotsuppsmdplegend(inputargs,w1,'Player 1 - LCP');
plotsuppsmdplegend(inputargs,w2,'Player 2 - LCP');


save solcooplcp w1 w2  val1 val2 rho1 rho2
